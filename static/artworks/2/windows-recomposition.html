<!doctype html><html><head><title>Windows Recomposition</title><meta charset="utf-8"><script id="fxhash-snippet">//---- do not edit the following code (you can indent as you wish)
      let search = new URLSearchParams(window.location.search)
      let alphabet = "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
      var fxhash = search.get('fxhash') || "oo" + Array(49).fill(0).map(_=>alphabet[(Math.random()*alphabet.length)|0]).join('')
      let b58dec = str=>[...str].reduce((p,c)=>p*alphabet.length+alphabet.indexOf(c)|0, 0)
      let fxhashTrunc = fxhash.slice(2)
      let regex = new RegExp(".{" + ((fxhash.length/4)|0) + "}", 'g')
      let hashes = fxhashTrunc.match(regex).map(h => b58dec(h))
      let sfc32 = (a, b, c, d) => {
        return () => {
          a |= 0; b |= 0; c |= 0; d |= 0
          var t = (a + b | 0) + d | 0
          d = d + 1 | 0
          a = b ^ b >>> 9
          b = c + (c << 3) | 0
          c = c << 21 | c >>> 11
          c = c + t | 0
          return (t >>> 0) / 4294967296
        }
      }
      var fxrand = sfc32(...hashes)
      // true if preview mode active, false otherwise
      // you can append preview=1 to the URL to simulate preview active
      var isFxpreview = search.get('preview') === "1"
      // call this method to trigger the preview
      function fxpreview() {
        console.log("fxhash: TRIGGER PREVIEW")
      }
      //---- /do not edit the following code</script>
    <style type="text/css">
        body {
            margin: 0;
            overflow: hidden;
        }
    </style>
</head><body><script src="three.min.js"></script>
<script type="text/javascript">
  (()=>{var o={379:o=>{o.exports="precision mediump float;\n\nconst float PI = 3.1415926535897932384626433832795;\n\nuniform vec2 resolution;\nuniform float time;\nuniform vec3 headerColor1;\nuniform vec3 headerColor2;\nuniform vec3 contentColor1;\nuniform vec3 contentColor2;\nuniform vec3 contentColor3;\nuniform vec3 contentColor4;\nuniform vec3 contentColor5;\n\nvarying float vIndex;\nvarying vec2 vUv;\nvarying vec3 vColor;\nvarying vec2 vResolution;\nvarying float vDirection;\nvarying float vRatio;\nvarying float vShowCode;\n\nfloat map(float value, float beforeMin, float beforeMax, float afterMin, float afterMax) {\n    return afterMin + (afterMax - afterMin) * ((value - beforeMin) / (beforeMax - beforeMin));\n}\n\nfloat rand(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nmat2 rotate(float angle) {\n    return mat2(\n        sin(angle), -cos(angle),\n        cos(angle), sin(angle)\n    );\n}\n\nfloat rect(vec2 size, vec2 uv, float edge) {\n    vec2 d = abs(uv - vec2(0.0)) - size + edge;\n    float l = length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n    return 1.0 - step(l - edge, 0.0);\n}\n\nfloat circle(float size, vec2 uv) {\n    return step(size, length(uv));\n}\n\nfloat borderCircle(float size, vec2 uv, float boldness) {\n    float c1 = circle(size, uv);\n    float c2 = circle(size - boldness, uv);\n    return abs(c1 - c2);\n}\n\nfloat close(vec2 uv, float size, float boldness) {\n    return borderCircle(size, uv, 0.01);\n}\n\nfloat _borderRect(vec2 size, vec2 uv, float boldness, float edge) {\n    float r1 = rect(size, uv, edge);\n    float r2 = rect(size - boldness, uv, edge);\n    float border = abs(r1 - r2);\n    return border;\n}\n\nvec3 borderRect(vec3 color, vec3 borderColor, vec2 size, vec2 uv, float boldness, float edge) {\n    float border = _borderRect(size, uv, boldness, edge);\n    color = mix(color, borderColor, border);\n    return color;\n}\n\nfloat maximizing(vec2 uv, vec2 size) {\n    return borderCircle(size.x, uv, 0.01);\n}\n\nfloat minimizing(vec2 uv, vec2 size) {\n    return borderCircle(size.x, uv, 0.01);\n}\n\nvec3 borderBtn(vec2 uv, vec3 color, vec3 bgColor, float size) {\n    float b = borderCircle(size, uv, 0.01);\n    color = mix(color, mix(bgColor * 0.6, bgColor * 0.4, uv.y * 20.0), b);\n    return color;\n}\n\nvec3 btn(vec2 uv, vec3 color, vec3 bgColor, float size) {\n    bgColor = mix(bgColor * 0.8, bgColor, smoothstep(0.0, 1.0, (uv.y + 0.45)));\n    bgColor = mix(vec3(0.93), bgColor, smoothstep(0.0, 0.06, length(vec2(uv.x, uv.y * 1.0 + 0.04))));\n    bgColor = mix(vec3(0.93), bgColor, smoothstep(0.0, 0.03, length(vec2(uv.x * 0.8, uv.y * 1.4 - 0.045))));\n    color = mix(bgColor, color, circle(size, uv));\n    return color;\n}\n\nvec3 code(vec2 uv, vec2 uvAspect, vec3 bgColor) {\n    float scaledY = vUv.y * 10.0;\n    float lineId = floor(scaledY);\n    float scaledX = rand(vec2(lineId)) * 0.5 + 0.2;\n    float colorId = mod(floor(rand(vec2(lineId)) * 5.0), 5.0);\n    vec3 _lineColor;\n    if (colorId == 0.0) {\n        _lineColor = contentColor1;\n    } else if (colorId == 1.0) {\n        _lineColor = contentColor2;\n    } else if (colorId == 2.0) {\n        _lineColor = contentColor3;\n    } else if (colorId == 3.0) {\n        _lineColor = contentColor4;\n    } else {\n        _lineColor = contentColor5;\n    }\n    vec3 lineColor = mix(_lineColor, bgColor, step(0.3, fract(scaledY)));\n    vec3 c = mix(bgColor, lineColor, (1.0 - step(uvAspect.x - scaledX, abs(uv.x + scaledX))));\n    c = mix(bgColor, c, 1.0 - step(uvAspect.x - 0.1, abs(uv.x)));\n    c = mix(bgColor, c, 1.0 - step(uvAspect.y - 0.3, abs(uv.y)));\n    return c;\n}\n\nvoid main() {\n    vec2 uv = (vUv.xy * vResolution * 2.0 - vResolution.xy) / min(vResolution.x, vResolution.y);\n    vec2 uvAspect = vResolution / min(vResolution.x, vResolution.y);\n\n    vec3 color = vec3(1.0);\n    vec2 dir = vec2(0.0);\n\n    if (vDirection > 0.5) {\n        // vertical\n        dir = vec2(1.0, 0.0);\n    } else {\n        // horizontal\n        dir = vec2(0.0, 1.0);\n    }\n\n    vec3 bgColor = vec3(0.0);\n    float bgId = mod(vIndex, 5.0);\n    if (bgId == 0.0) {\n        bgColor = contentColor1;\n    } else if (bgId == 1.0) {\n        bgColor = contentColor2;\n    } else if (bgId == 2.0) {\n        bgColor = contentColor3;\n    } else if (bgId == 3.0) {\n        bgColor = contentColor4;\n    } else {\n        bgColor = contentColor5;\n    }\n    vec3 windowBorderColor = vec3(0.8);\n    vec3 closeButtonBGColor = vec3(1.0, 0.4, 0.5);\n    vec3 maximizingButtonBGColor = vec3(0.0, 0.8, 0.3);\n    vec3 minimizingButtonBGColor = vec3(1.0, 0.75, 0.0);\n    vec3 closeButtonColor = vec3(0.25);\n    float edgeSize = 0.2;\n    vec2 maxMove = uvAspect;\n    vec2 move = -1.0 * maxMove;\n    vec2 dd = vec2(move.x, 0.0);\n    float edge = 1.0 - step(-edgeSize, uv.y - maxMove.y);\n    vec3 edgeColor = mix(headerColor1, headerColor2 * 0.85, map(uv.y - maxMove.y, -edgeSize, 0.0, 1.0, 0.0));\n    float windowBorderBoldness = 0.01;\n    float windowRadius = 0.03;\n    vec2 closeButton = vec2(uv.x + move.x, uv.y - maxMove.y);\n    vec2 lastCloseButton = vec2(uv.x + uvAspect.x * 1.0, uv.y - maxMove.y);\n    vec2 maximizingButton = closeButton;\n    vec2 lastMaximizingButton = lastCloseButton;\n    vec2 minimizingButton = closeButton;\n    vec2 lastMinimizingButton = lastCloseButton;\n\n    // code\n    if (vShowCode > 0.5 && vDirection < 0.0) {\n        bgColor = code(uv, uvAspect, bgColor);\n    }\n\n    // window\n    bgColor = mix(edgeColor, bgColor, edge);\n    color = mix(bgColor, color, rect(maxMove, uv, windowRadius));\n    color = borderRect(color, windowBorderColor, uvAspect, uv, windowBorderBoldness, windowRadius);\n\n    vec2 btnSize = vec2(edgeSize * 0.2);\n    float btnXOssset = 0.01;\n    float btnYOssset = 0.0;\n\n    // close button\n    vec2 lastColseBtnPos = lastCloseButton + vec2(-edgeSize * 0.5 - btnXOssset, edgeSize * 0.5 + btnYOssset);\n    color = btn(lastColseBtnPos, color, closeButtonBGColor, btnSize.x);\n    color = borderBtn(lastColseBtnPos, color, closeButtonBGColor, 0.05);\n\n    float offf = -0.2;\n    vec2 _minimizingPos = vec2(-edgeSize * (1.3 + offf) - btnXOssset, edgeSize * 0.5 + btnYOssset);\n    vec2 _maximizingPos = vec2(-edgeSize * (2.1 + offf * 2.0) - btnXOssset, edgeSize * 0.5 + btnYOssset);\n\n    // maximizing button\n    vec2 lastMaximizingBtnPos = lastMaximizingButton + _maximizingPos;\n    color = btn(lastMaximizingBtnPos, color, maximizingButtonBGColor, btnSize.x);\n    color = borderBtn(lastMaximizingBtnPos, color, maximizingButtonBGColor, 0.05);\n\n    // minimizing button\n    vec2 lastMinimizingBtnPos = lastMinimizingButton + _minimizingPos;\n    color = btn(lastMinimizingBtnPos, color, minimizingButtonBGColor, btnSize.x);\n    color = borderBtn(lastMinimizingBtnPos, color, minimizingButtonBGColor, 0.05);\n\n    gl_FragColor = vec4(color, 1.0);\n}"},579:o=>{o.exports="precision mediump float;\n\nconst float PI = 3.1415926535897932384626433832795;\n\nuniform vec2 resolution;\nuniform float time;\nuniform vec3 headerColor1;\nuniform vec3 headerColor2;\nuniform vec3 contentColor1;\nuniform vec3 contentColor2;\nuniform vec3 contentColor3;\nuniform vec3 contentColor4;\nuniform vec3 contentColor5;\n\nvarying float vIndex;\nvarying vec2 vUv;\nvarying vec3 vColor;\nvarying vec2 vResolution;\nvarying float vDirection;\nvarying float vRatio;\nvarying float vShowCode;\n\nfloat map(float value, float beforeMin, float beforeMax, float afterMin, float afterMax) {\n    return afterMin + (afterMax - afterMin) * ((value - beforeMin) / (beforeMax - beforeMin));\n}\n\nfloat rand(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nmat2 rotate(float angle) {\n    return mat2(\n        sin(angle), -cos(angle),\n        cos(angle), sin(angle)\n    );\n}\n\nfloat rect(vec2 size, vec2 uv, float edge) {\n    vec2 d = abs(uv - vec2(0.0)) - size + edge;\n    float l = length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n    return 1.0 - step(l - edge, 0.0);\n}\n\nfloat circle(float size, vec2 uv) {\n    return step(size, length(uv));\n}\n\nfloat close(vec2 uv, float size, float boldness) {\n    return 0.0;\n}\n\nfloat _borderRect(vec2 size, vec2 uv, float boldness, float edge) {\n    float r1 = rect(size, uv, edge);\n    float r2 = rect(size - boldness, uv, edge);\n    float border = abs(r1 - r2);\n    return border;\n}\n\nvec3 borderRect(vec3 color, vec3 borderColor, vec2 size, vec2 uv, float boldness, float edge) {\n    float border = _borderRect(size, uv, boldness, edge);\n    color = mix(color, borderColor, border);\n    return color;\n}\n\nfloat maximizing(vec2 uv, vec2 size) {\n    return 0.0;\n}\n\nfloat minimizing(vec2 uv, vec2 size) {\n    return 0.0;\n}\n\nvec3 code(vec2 uv, vec2 uvAspect, vec3 bgColor) {\n    float scaledY = vUv.y * 10.0;\n    float lineId = floor(scaledY);\n    float scaledX = rand(vec2(lineId)) * 0.5 + 0.2;\n    float colorId = mod(floor(rand(vec2(lineId)) * 5.0), 5.0);\n    vec3 _lineColor;\n    if (colorId == 0.0) {\n        _lineColor = contentColor1;\n    } else if (colorId == 1.0) {\n        _lineColor = contentColor2;\n    } else if (colorId == 2.0) {\n        _lineColor = contentColor3;\n    } else if (colorId == 3.0) {\n        _lineColor = contentColor4;\n    } else {\n        _lineColor = contentColor5;\n    }\n    vec3 lineColor = mix(_lineColor, bgColor, step(0.3, fract(scaledY)));\n    vec3 c = mix(bgColor, lineColor, (1.0 - step(uvAspect.x - scaledX, abs(uv.x + scaledX))));\n    c = mix(bgColor, c, 1.0 - step(uvAspect.x - 0.1, abs(uv.x)));\n    c = mix(bgColor, c, 1.0 - step(uvAspect.y - 0.3, abs(uv.y)));\n    return c;\n}\n\nvoid main() {\n    vec2 uv = (vUv.xy * vResolution * 2.0 - vResolution.xy) / min(vResolution.x, vResolution.y);\n    vec2 uvAspect = vResolution / min(vResolution.x, vResolution.y);\n\n    float id = floor(mod(vIndex, 4.0));\n    if (id == 0.0) {\n        id = 1.0;\n    }\n\n    vec3 color = vec3(1.0);\n    vec2 dir = vec2(0.0);\n\n    if (vDirection > 0.5) {\n        // vertical\n        dir = vec2(1.0, 0.0);\n    } else {\n        // horizontal\n        dir = vec2(0.0, 1.0);\n    }\n\n    vec3 bgColor = vec3(1.0);\n    float bgId = mod(vIndex, 5.0);\n    if (bgId == 0.0) {\n        bgColor = contentColor1;\n    } else if (bgId == 1.0) {\n        bgColor = contentColor2;\n    } else if (bgId == 2.0) {\n        bgColor = contentColor3;\n    } else if (bgId == 3.0) {\n        bgColor = contentColor4;\n    } else {\n        bgColor = contentColor5;\n    }\n    vec3 edgeColor = mix(headerColor1, headerColor2, uv.x / uvAspect.x);\n    vec3 windowBorderColor = vec3(0.8);\n    vec3 buttonBorderColor = vec3(1.0);\n    vec3 lastEdgeColor = edgeColor;\n    vec3 closeButtonBGColor = vec3(1.0, 0.4, 0.5);\n    vec3 miximizingButtonBGColor = vec3(0.0, 0.8, 0.3);\n    vec3 minimizingButtonBGColor = vec3(1.0, 0.75, 0.0);\n    vec3 closeButtonColor = vec3(0.25);\n    float edgeSize = 0.2;\n    vec2 ballSize = vec2(0.0);\n    float margin = 0.0;\n    vec2 maxMove = (uvAspect - margin) - ballSize;\n    vec2 move = -1.0 * maxMove;\n    vec2 dd = vec2(move.x - ballSize.x, 0.0);\n    float edge = 1.0 - step(-edgeSize, uv.y - maxMove.y);\n    float windowBorderBoldness = 0.01;\n    float buttonBorderBoldness = 0.01;\n    float windowRadius = 0.06;\n    float buttonRadius = 0.015;\n    vec2 closeButton = vec2(uv.x + move.x, uv.y - maxMove.y);\n    vec2 lastCloseButton = vec2(uv.x + uvAspect.x * 1.0, uv.y - maxMove.y);\n    vec2 maximizingButton = closeButton;\n    vec2 lastMaximizingButton = lastCloseButton;\n    vec2 minimizingButton = closeButton;\n    vec2 lastMinimizingButton = lastCloseButton;\n\n    // code\n    if (vShowCode > 0.5 && vDirection < 0.0) {\n        bgColor = code(uv, uvAspect, bgColor);\n    }\n\n    // window\n    bgColor = mix(lastEdgeColor, bgColor, edge);\n    color = mix(bgColor, color, rect(maxMove, uv, windowRadius));\n    color = borderRect(color, windowBorderColor, uvAspect, uv, windowBorderBoldness, windowRadius);\n\n    vec2 closeButtonProp = vec2(0.06, 7.0);  // size, boldness\n\n    vec2 btnSize = vec2(edgeSize * 0.2);\n    float btnXOssset = 0.01;\n    float btnYOssset = 0.0;\n\n    // close button\n    vec2 lastColseBtnPos = lastCloseButton + vec2(-edgeSize * 0.5 - btnXOssset, edgeSize * 0.5 + btnYOssset);\n    color = mix(closeButtonBGColor, color, circle(btnSize.x, lastColseBtnPos));\n    color = mix(color, closeButtonColor, close(lastColseBtnPos, closeButtonProp.x, closeButtonProp.y));\n\n    float offf = -0.2;\n    vec2 _minimizingPos = vec2(-edgeSize * (1.3 + offf) - btnXOssset, edgeSize * 0.5 + btnYOssset);\n    vec2 _maximizingPos = vec2(-edgeSize * (2.1 + offf * 2.0) - btnXOssset, edgeSize * 0.5 + btnYOssset);\n\n    // maximizing button\n    vec2 lastMaximizingBtnPos = lastMaximizingButton + _maximizingPos;\n    color = mix(miximizingButtonBGColor, color, circle(btnSize.x, lastMaximizingBtnPos));\n    color = mix(color, closeButtonColor, maximizing(lastMaximizingBtnPos, vec2(0.05, 0.05)));\n\n    // minimizing button\n    vec2 lastMinimizingBtnPos = lastMinimizingButton + _minimizingPos;\n    color = mix(minimizingButtonBGColor, color, circle(btnSize.x, lastMinimizingBtnPos));\n    color = mix(color, closeButtonColor, minimizing(lastMinimizingBtnPos, vec2(0.05, 0.05)));\n\n    gl_FragColor = vec4(color, 1.0);\n}"},938:o=>{o.exports="precision mediump float;\n\nconst float PI = 3.1415926535897932384626433832795;\n\nuniform vec2 resolution;\nuniform float time;\nuniform vec3 headerColor1;\nuniform vec3 headerColor2;\nuniform vec3 contentColor1;\nuniform vec3 contentColor2;\nuniform vec3 contentColor3;\nuniform vec3 contentColor4;\nuniform vec3 contentColor5;\n\nvarying float vIndex;\nvarying vec2 vUv;\nvarying vec2 vResolution;\nvarying float vDirection;\nvarying float vRatio;\nvarying float vShowCode;\n\nfloat map(float value, float beforeMin, float beforeMax, float afterMin, float afterMax) {\n    return afterMin + (afterMax - afterMin) * ((value - beforeMin) / (beforeMax - beforeMin));\n}\n\nfloat rand(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nmat2 rotate(float angle) {\n    return mat2(\n        sin(angle), -cos(angle),\n        cos(angle), sin(angle)\n    );\n}\n\nfloat rect(vec2 size, vec2 uv) {\n    float cc = step(size.x, length(uv.x));\n    return max(cc, step(size.y, length(uv.y)));\n}\n\nfloat close(vec2 uv, float size, float boldness) {\n    uv *= rotate(45.0 * PI / 180.0);\n    float c = rect(vec2(size), vec2(uv.x, uv.y * boldness));\n    return min(c, rect(vec2(size), vec2(uv.x * boldness, uv.y)));\n}\n\nfloat borderRect(vec2 size, vec2 uv, float boldness) {\n    float r1 = rect(size, uv);\n    float r2 = rect(size - boldness, uv);\n    float border = abs(r1 - r2);\n    return border;\n}\n\nvec3 borderRect(vec3 color, vec2 size, vec2 uv, vec2 uvAspect) {\n    float border = borderRect(size, uv, 0.015);\n\n    float d = step(0.0, dot(uv * rotate(0.0 * PI / 180.0), uvAspect));\n    vec3 borderColor = mix(vec3(1.0), vec3(0.0), d);\n    color = mix(color, borderColor, border);\n\n    return color;\n}\n\nfloat maximizing(vec2 uv, vec2 size) {\n    float border = borderRect(size, uv, 0.015);\n    return border;\n}\n\nfloat minimizing(vec2 uv, vec2 size) {\n    uv.y += 0.035;\n    float border = rect(vec2(size.x, size.y * 0.2), uv);\n    return border;\n}\n\nvec3 code(vec2 uv, vec2 uvAspect, vec3 bgColor) {\n    float scaledY = vUv.y * 10.0;\n    float lineId = floor(scaledY);\n    float scaledX = rand(vec2(lineId)) * 0.5 + 0.2;\n    float colorId = mod(floor(rand(vec2(lineId)) * 5.0), 5.0);\n    vec3 _lineColor;\n    if (colorId == 0.0) {\n        _lineColor = contentColor1;\n    } else if (colorId == 1.0) {\n        _lineColor = contentColor2;\n    } else if (colorId == 2.0) {\n        _lineColor = contentColor3;\n    } else if (colorId == 3.0) {\n        _lineColor = contentColor4;\n    } else {\n        _lineColor = contentColor5;\n    }\n    vec3 lineColor = mix(_lineColor, bgColor, step(0.3, fract(scaledY)));\n    vec3 c = mix(bgColor, lineColor, (1.0 - step(uvAspect.x - scaledX, abs(uv.x + scaledX))));\n    c = mix(bgColor, c, 1.0 - step(uvAspect.x - 0.1, abs(uv.x)));\n    c = mix(bgColor, c, 1.0 - step(uvAspect.y - 0.3, abs(uv.y)));\n    return c;\n}\n\nvoid main() {\n    vec2 uv = (vUv.xy * vResolution * 2.0 - vResolution.xy) / min(vResolution.x, vResolution.y);\n    vec2 uvAspect = vResolution / min(vResolution.x, vResolution.y);\n\n    vec3 color = vec3(1.0);\n    vec2 dir = vec2(0.0);\n\n    if (vDirection > 0.5) {\n        // vertical\n        dir = vec2(1.0, 0.0);\n    } else {\n        // horizontal\n        dir = vec2(0.0, 1.0);\n    }\n\n    vec3 bgColor = vec3(0.0);\n    float bgId = mod(vIndex, 5.0);\n    if (bgId == 0.0) {\n        bgColor = contentColor1;\n    } else if (bgId == 1.0) {\n        bgColor = contentColor2;\n    } else if (bgId == 2.0) {\n        bgColor = contentColor3;\n    } else if (bgId == 3.0) {\n        bgColor = contentColor4;\n    } else {\n        bgColor = contentColor5;\n    }\n    vec3 g = mix(headerColor1, headerColor2, uv.x / uvAspect.x);\n    vec3 edgeColor = g;\n    vec3 lastEdgeColor = g;\n    vec3 closeButtonBGColor = vec3(0.7);\n    vec3 maximizingButtonBGColor = vec3(0.7);\n    vec3 minimizingButtonBGColor = vec3(0.7);\n    vec3 closeButtonColor = vec3(0.2);\n    vec2 closeButton = vec2(0.0);\n    vec2 lastCloseButton = vec2(0.0);\n    vec2 maximizingButton = vec2(0.0);\n    vec2 lastMaximizingButton = vec2(0.0);\n    vec2 minimizingButton = vec2(0.0);\n    vec2 lastMinimizingButton = vec2(0.0);\n    float edgeSize = 0.2;\n\n    vec2 ballSize = vec2(0.0);\n    float margin = 0.0;\n    vec2 maxMove = (uvAspect - margin);\n    vec2 move = (0.0 * 2.0 - 1.0) * maxMove;\n    vec2 dd = vec2(move.x, 0.0);\n    float edge = 1.0 - step(-edgeSize, uv.y - maxMove.y);\n    float lastEdge = edge;\n\n    closeButton = vec2(uv.x + move.x - uvAspect.x * 2.0, uv.y - maxMove.y);\n    lastCloseButton = vec2(uv.x - uvAspect.x, uv.y - maxMove.y);\n    maximizingButton = closeButton;\n    lastMaximizingButton = lastCloseButton;\n    minimizingButton = closeButton;\n    lastMinimizingButton = lastCloseButton;\n\n    // rect for window\n    float cc = rect(ballSize, uv + dd);\n\n    // code\n    if (vShowCode > 0.5 && vDirection < 0.0) {\n        bgColor = code(uv, uvAspect, bgColor);\n    }\n\n    // window\n    bgColor = mix(lastEdgeColor, bgColor, lastEdge);\n    color = mix(color, bgColor, cc);\n    color = borderRect(color, uvAspect, uv, uvAspect);\n\n    vec2 closeButtonProp = vec2(0.06, 7.0);  // size, boldness\n\n    vec2 btnSize = vec2(edgeSize * 0.4);\n    float btnYOssset = 0.01;\n\n    // close button\n    vec2 lastColseBtnPos = lastCloseButton + vec2(edgeSize * 0.5, edgeSize * 0.5 + btnYOssset);\n    color = mix(closeButtonBGColor, color, rect(btnSize, lastColseBtnPos));\n    color = mix(closeButtonColor, color, close(lastColseBtnPos, closeButtonProp.x, closeButtonProp.y));\n    color = borderRect(color, btnSize, lastColseBtnPos, vec2(1.0));\n\n    vec2 _maximizingPos = vec2(edgeSize * 1.4, edgeSize * 0.5 + btnYOssset);\n    vec2 _minimizingPos = vec2(edgeSize * 2.2, edgeSize * 0.5 + btnYOssset);\n\n    // maximizing button\n    vec2 lastMaximizingBtnPos = lastMaximizingButton + _maximizingPos;\n    color = mix(maximizingButtonBGColor, color, rect(btnSize, lastMaximizingBtnPos));\n    color = mix(color, closeButtonColor, maximizing(lastMaximizingBtnPos, vec2(0.05, 0.05)));\n    color = borderRect(color, btnSize, lastMaximizingBtnPos, vec2(1.0));\n\n    // minimizing button\n    vec2 lastMinimizingBtnPos = lastMinimizingButton + _minimizingPos;\n    color = mix(minimizingButtonBGColor, color, rect(btnSize, lastMinimizingBtnPos));\n    color = mix(closeButtonColor, color, minimizing(lastMinimizingBtnPos, vec2(0.05, 0.05)));\n    color = borderRect(color, btnSize, lastMinimizingBtnPos, vec2(1.0));\n\n    gl_FragColor = vec4(color, 1.0);\n}"},125:o=>{o.exports="precision mediump float;\n\nconst float PI = 3.1415926535897932384626433832795;\n\nuniform vec2 resolution;\nuniform float time;\nuniform vec3 headerColor1;\nuniform vec3 headerColor2;\nuniform vec3 contentColor1;\nuniform vec3 contentColor2;\nuniform vec3 contentColor3;\nuniform vec3 contentColor4;\nuniform vec3 contentColor5;\n\nvarying float vIndex;\nvarying vec2 vUv;\nvarying vec2 vResolution;\nvarying float vDirection;\nvarying float vRatio;\nvarying float vShowCode;\n\nfloat map(float value, float beforeMin, float beforeMax, float afterMin, float afterMax) {\n    return afterMin + (afterMax - afterMin) * ((value - beforeMin) / (beforeMax - beforeMin));\n}\n\nfloat rand(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nmat2 rotate(float angle) {\n    return mat2(\n        sin(angle), -cos(angle),\n        cos(angle), sin(angle)\n    );\n}\n\nfloat rect(vec2 size, vec2 uv, float edge) {\n    vec2 d = abs(uv - vec2(0.0)) - size + edge;\n    float l = length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n    return 1.0 - step(l - edge, 0.0);\n}\n\nfloat close(vec2 uv, float size, float boldness) {\n    uv *= rotate(45.0 * PI / 180.0);\n    float c = rect(vec2(size), vec2(uv.x, uv.y * boldness), 0.0);\n    return min(c, rect(vec2(size), vec2(uv.x * boldness, uv.y), 0.0));\n}\n\nfloat _borderRect(vec2 size, vec2 uv, float boldness, float edge) {\n    float r1 = rect(size, uv, edge);\n    float r2 = rect(size - boldness, uv, edge);\n    float border = abs(r1 - r2);\n    return border;\n}\n\nvec3 borderRect(vec3 color, vec3 borderColor, vec2 size, vec2 uv, float boldness, float edge) {\n    float border = _borderRect(size, uv, boldness, edge);\n    color = mix(color, borderColor, border);\n    return color;\n}\n\nfloat maximizing(vec2 uv, vec2 size) {\n    float border = _borderRect(size, uv, 0.015, 0.0);\n    return border;\n}\n\nfloat minimizing(vec2 uv, vec2 size) {\n    uv.y += 0.035;\n    float border = rect(vec2(size.x, size.y * 0.2), uv, 0.0);\n    return border;\n}\n\nvec3 code(vec2 uv, vec2 uvAspect, vec3 bgColor) {\n    float scaledY = vUv.y * 10.0;\n    float lineId = floor(scaledY);\n    float scaledX = rand(vec2(lineId)) * 0.5 + 0.2;\n    float colorId = mod(floor(rand(vec2(lineId)) * 5.0), 5.0);\n    vec3 _lineColor;\n    if (colorId == 0.0) {\n        _lineColor = contentColor1;\n    } else if (colorId == 1.0) {\n        _lineColor = contentColor2;\n    } else if (colorId == 2.0) {\n        _lineColor = contentColor3;\n    } else if (colorId == 3.0) {\n        _lineColor = contentColor4;\n    } else {\n        _lineColor = contentColor5;\n    }\n    vec3 lineColor = mix(_lineColor, bgColor, step(0.3, fract(scaledY)));\n    vec3 c = mix(bgColor, lineColor, (1.0 - step(uvAspect.x - scaledX, abs(uv.x + scaledX))));\n    c = mix(bgColor, c, 1.0 - step(uvAspect.x - 0.1, abs(uv.x)));\n    c = mix(bgColor, c, 1.0 - step(uvAspect.y - 0.3, abs(uv.y)));\n    return c;\n}\n\nvoid main() {\n    vec2 uv = (vUv.xy * vResolution * 2.0 - vResolution.xy) / min(vResolution.x, vResolution.y);\n    vec2 uvAspect = vResolution / min(vResolution.x, vResolution.y);\n\n    float id = floor(mod(vIndex, 4.0));\n    if (id == 0.0) {\n        id = 1.0;\n    }\n\n    vec3 color = vec3(1.0);\n    vec2 dir = vec2(0.0);\n\n    if (vDirection > 0.5) {\n        // vertical\n        dir = vec2(1.0, 0.0);\n    } else {\n        // horizontal\n        dir = vec2(0.0, 1.0);\n    }\n\n    vec3 bgColor = vec3(0.0);\n    float bgId = mod(vIndex, 5.0);\n    if (bgId == 0.0) {\n        bgColor = contentColor1;\n    } else if (bgId == 1.0) {\n        bgColor = contentColor2;\n    } else if (bgId == 2.0) {\n        bgColor = contentColor3;\n    } else if (bgId == 3.0) {\n        bgColor = contentColor4;\n    } else {\n        bgColor = contentColor5;\n    }\n    vec3 edgeColor = mix(headerColor1, headerColor2, uv.x / uvAspect.x);\n    vec3 windowBorderColor = edgeColor;\n    vec3 buttonBorderColor = vec3(1.0);\n    vec3 lastEdgeColor = edgeColor;\n    vec3 closeButtonBGColor = vec3(0.95, 0.2, 0.0);\n    vec3 maximizingButtonBGColor = edgeColor;\n    vec3 minimizingButtonBGColor = edgeColor;\n    float edgeSize = 0.2;\n    float idTime = 0.0;\n    float ballPosition = mod(idTime, 4.0);\n    vec2 ballSize = vec2(0.0);\n    float margin = 0.0;\n    vec2 maxMove = (uvAspect - margin) - ballSize;\n    vec2 move = (fract(idTime) * 2.0 - 1.0) * maxMove;\n    vec2 dd = vec2(move.x - ballSize.x, 0.0);\n    float edge = 1.0 - step(-edgeSize, uv.y - maxMove.y);\n    float windowBorderBoldness = 0.025;\n    float buttonBorderBoldness = 0.01;\n    float windowRadius = 0.06;\n    float buttonRadius = 0.015;\n    vec3 closeButtonColor = buttonBorderColor;\n    vec2 closeButton = vec2(uv.x + move.x - uvAspect.x * 2.0, uv.y - maxMove.y);\n    vec2 lastCloseButton = vec2(uv.x - uvAspect.x, uv.y - maxMove.y);\n    vec2 maximizingButton = closeButton;\n    vec2 lastMaximizingButton = lastCloseButton;\n    vec2 minimizingButton = closeButton;\n    vec2 lastMinimizingButton = lastCloseButton;\n\n    // code\n    if (vShowCode > 0.5 && vDirection < 0.0) {\n        bgColor = code(uv, uvAspect, bgColor);\n    }\n\n    // window\n    bgColor = mix(lastEdgeColor, bgColor, edge);\n    color = mix(bgColor, color, rect(maxMove, uv, windowRadius));\n    color = borderRect(color, windowBorderColor, uvAspect, uv, windowBorderBoldness, windowRadius);\n\n    vec2 closeButtonProp = vec2(0.06, 7.0);  // size, boldness\n\n    vec2 btnSize = vec2(edgeSize * 0.4);\n    float btnXOssset = 0.01;\n    float btnYOssset = 0.0;\n\n    // close button\n    vec2 lastColseBtnPos = lastCloseButton + vec2(edgeSize * 0.5 + btnXOssset, edgeSize * 0.5 + btnYOssset);\n    color = mix(closeButtonBGColor, color, rect(btnSize, lastColseBtnPos, buttonRadius));\n    color = mix(closeButtonColor, color, close(lastColseBtnPos, closeButtonProp.x, closeButtonProp.y));\n    color = borderRect(color, buttonBorderColor, btnSize, lastColseBtnPos, buttonBorderBoldness, buttonRadius);\n\n    float offf = 0.1;\n    vec2 _maximizingPos = vec2(edgeSize * (1.3 + offf) + btnXOssset, edgeSize * 0.5 + btnYOssset);\n    vec2 _minimizingPos = vec2(edgeSize * (2.1 + offf * 2.0) + btnXOssset, edgeSize * 0.5 + btnYOssset);\n\n    // maximizing button\n    vec2 lastMaximizingBtnPos = lastMaximizingButton + _maximizingPos;\n    color = mix(maximizingButtonBGColor, color, rect(btnSize, lastMaximizingBtnPos, buttonRadius));\n    color = mix(color, closeButtonColor, maximizing(lastMaximizingBtnPos, vec2(0.05, 0.05)));\n    color = borderRect(color, buttonBorderColor, btnSize, lastMaximizingBtnPos, buttonBorderBoldness, buttonRadius);\n\n    // minimizing button\n    vec2 lastMinimizingBtnPos = lastMinimizingButton + _minimizingPos;\n    color = mix(minimizingButtonBGColor, color, rect(btnSize, lastMinimizingBtnPos, buttonRadius));\n    color = mix(closeButtonColor, color, minimizing(lastMinimizingBtnPos, vec2(0.05, 0.05)));\n    color = borderRect(color, buttonBorderColor, btnSize, lastMinimizingBtnPos, buttonBorderBoldness, buttonRadius);\n\n    gl_FragColor = vec4(color, 1.0);\n}"},223:o=>{o.exports="precision mediump float;\n\nconst float PI = 3.1415926535897932384626433832795;\n\nattribute float index;\nattribute float totalIndex;\nattribute vec3 position;\nattribute vec3 translate;\nattribute vec2 uv;\nattribute vec2 size;\nattribute vec2 padding;\nattribute float direction;\nattribute float ratio;\nattribute vec2 weight;\nattribute float showCode;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float time;\nuniform float uWidth;\nuniform float uHeight;\nuniform float duration;\n\nvarying float vIndex;\nvarying float vTotalIndex;\nvarying vec2 vUv;\nvarying vec3 vColor;\nvarying vec2 vResolution;\nvarying float vDirection;\nvarying float vRatio;\nvarying vec2 vWeight;\nvarying float vShowCode;\n\nvoid main() {\n    vIndex = index;\n    vTotalIndex = totalIndex;\n    vUv = uv;\n    // Actual resolution of rect by vertex with padding.\n    vResolution = vec2(size.x - padding.x, size.y - padding.y);\n    vDirection = direction;\n    vRatio = ratio;\n    vWeight = weight;\n    vShowCode = showCode;\n\n    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n    gl_Position = projectionMatrix * mvPosition;\n}"},203:(o,e,n)=>{var t={"./MacOSXLeopard.frag":379,"./MacOSXYosemite.frag":579,"./Windows98.frag":938,"./WindowsXP.frag":125};function i(o){var e=r(o);return n(e)}function r(o){if(!n.o(t,o)){var e=new Error("Cannot find module '"+o+"'");throw e.code="MODULE_NOT_FOUND",e}return t[o]}i.keys=function(){return Object.keys(t)},i.resolve=r,o.exports=i,i.id=203}},e={};function n(t){var i=e[t];if(void 0!==i)return i.exports;var r=e[t]={exports:{}};return o[t](r,r.exports,n),r.exports}n.o=(o,e)=>Object.prototype.hasOwnProperty.call(o,e),(()=>{"use strict";const o=o=>{const e=(o=o.replace("#","")).match(/.{1,2}/g);return[parseInt(e[0],16)/255,parseInt(e[1],16)/255,parseInt(e[2],16)/255]};class e{constructor(o){this.useA=!1;let e=function(o){let e=parseInt(o.substr(0,8),16),n=parseInt(o.substr(8,8),16),t=parseInt(o.substr(16,8),16),i=parseInt(o.substr(24,8),16);return function(){e|=0,n|=0,t|=0,i|=0;let o=(e+n|0)+i|0;return i=i+1|0,e=n^n>>>9,n=t+(t<<3)|0,t=t<<21|t>>>11,t=t+o|0,(o>>>0)/4294967296}};this.prngA=new e(o.substr(2,32)),this.prngB=new e(o.substr(34,32));for(let o=0;o<1e6;o+=2)this.prngA(),this.prngB()}random_dec(){return this.useA=!this.useA,this.useA?this.prngA():this.prngB()}random_num(o,e){return o+(e-o)*this.random_dec()}random_int(o,e){return Math.floor(this.random_num(o,e+1))}random_bool(o){return this.random_dec()<o}random_choice(o){return o[this.random_int(0,o.length-1)]}}let t,i;const r={random:null,calculateFeatures:o=>(r.random=new e(o.hash),function(o){t={windows98:"Windows 98"};const e={Windows98:("https://coolors.co/0100a8-58a8a9-bfc7c8-bbc2c2-cdd3d5","https://coolors.co/0100a8-58a8a9-bfc7c8-bbc2c2-cdd3d5".split("/")[3].split("-").map((o=>`#${o}`)))};i={Windows98:{header1:e.Windows98[0],header2:e.Windows98[0],content1:e.Windows98[2],content2:e.Windows98[2],content3:e.Windows98[3],content4:e.Windows98[3],content5:e.Windows98[4]}};const n=new class{constructor(o){this.useA=!1;let e=function(o){let e=parseInt(o.substr(0,8),16),n=parseInt(o.substr(8,8),16),t=parseInt(o.substr(16,8),16),i=parseInt(o.substr(24,8),16);return function(){e|=0,n|=0,t|=0,i|=0;let o=(e+n|0)+i|0;return i=i+1|0,e=n^n>>>9,n=t+(t<<3)|0,t=t<<21|t>>>11,t=t+o|0,(o>>>0)/4294967296}};this.prngA=new e(o.substr(2,32)),this.prngB=new e(o.substr(34,32));for(let o=0;o<1e6;o+=2)this.prngA(),this.prngB()}random_dec(){return this.useA=!this.useA,this.useA?this.prngA():this.prngB()}random_num(o,e){return o+(e-o)*this.random_dec()}random_int(o,e){return Math.floor(this.random_num(o,e+1))}random_bool(o){return this.random_dec()<o}random_choice(o){return o[this.random_int(0,o.length-1)]}}(o.hash),r=[t.windows98];return{type:n.random_choice(r),palette:n.random_choice(Object.keys(i)),tileRatioOffset:n.random_num(.2,.5),dynamic:!0,division:n.random_int(4,8),divider:0,code:!1}}(o)),getPaletteAsRGB:e=>{let n={};const t=i[e];for(let e in t)n[e]=o(t[e]);return n},getRandom:()=>r.random.random_dec()},l={hash:fxhash},s=r.calculateFeatures(l);window.$fxhashFeatures=s,console.log(s);const c=n(223),a=n(203)(`./${s.type.replaceAll(" ","")}.frag`),v=new THREE.Clock,d=new THREE.Scene,u=new THREE.Color(.8,.8,.688);d.background=new THREE.Color(1,1,1);let m=s.division;const f=s.divider;let g,b,h,C=[],x=[],z=[],B=[],p=[],w=[],y=[],R=[],M=[],P=[],S=0,E=[0];const I={time:{type:"f",value:1},resolution:{type:"v2",value:new THREE.Vector2},texture:{type:"t",value:null},headerColor1:{type:"v3",value:new THREE.Vector3},headerColor2:{type:"v3",value:new THREE.Vector3},contentColor1:{type:"v3",value:new THREE.Vector3},contentColor2:{type:"v3",value:new THREE.Vector3},contentColor3:{type:"v3",value:new THREE.Vector3},contentColor4:{type:"v3",value:new THREE.Vector3},contentColor5:{type:"v3",value:new THREE.Vector3},bgColor:{type:"v3",value:new THREE.Vector3(u.r,u.g,u.b)}},A=(o,e,n,t,i)=>t+(o-e)/(n-e)*(i-t),_=window.innerWidth/window.innerHeight,T=new THREE.PerspectiveCamera(45,_,1,1e4),H=window.innerHeight,O=H/Math.tan(45*Math.PI/360)/2;T.position.z=O;const G=new THREE.WebGLRenderer;document.body.appendChild(G.domElement);const X=()=>{v.getDelta();const o=v.elapsedTime;E[0]=o,I.time.value=E[0],h&&s.dynamic&&h.update(),G.render(d,T),requestAnimationFrame(X)},Y=()=>{const o=window.innerWidth,e=window.innerHeight;U(o,e)},U=(o,e)=>{T.aspect=o/e,T.updateProjectionMatrix(),I.resolution.value=new THREE.Vector2(o,e),G.setPixelRatio(window.devicePixelRatio),G.setSize(o,e)};class D{constructor(o,e,n,t,i){if(this.x=o,this.y=e,this.z=0,this.w=n,this.h=t,this.age=i,this.children=[],this.ratio=.5+(2*r.getRandom()-1)*s.tileRatioOffset,this.lastRatio=this.ratio,this.targetRatio=this.ratio,this.id=-1,this.impulse=0,this.updateCount=0,this.frame=0,this.maxFrame=200+Math.floor(100*r.getRandom()),this.easing=W[Math.floor(r.getRandom()*W.length)],this.age<m){const o=this.age+1;if(this.age%2==0){const e=this.w*this.ratio,n=this.w*(1-this.ratio);this.children[0]=new D(this.x,this.y,e,this.h,o),this.children[1]=new D(this.x+e,this.y,n,this.h,o)}else{const e=this.h*this.ratio,n=this.h*(1-this.ratio);this.children[0]=new D(this.x,this.y,this.w,e,o),this.children[1]=new D(this.x,this.y+e,this.w,n,o)}}else this.draw(!1)}updateTarget(o){if(this.children.length>0){this.frame=0,this.lastRatio=this.ratio,this.targetRatio=o||r.getRandom();const e=o||null;this.children[0].updateTarget(e),this.children[1].updateTarget(e)}}update(o=null){if(o&&(this.x=o.x,this.y=o.y,this.w=o.w,this.h=o.h,this.impulse=o.impulse),this.children.length>0){let o=Math.abs(this.ratio-this.targetRatio);if(o<1e-4&&(this.frame=0,this.targetRatio=A(r.getRandom(),0,1,0,1),this.updateCount++,this.lastRatio=this.ratio),o<.005&&(o=0),this.ratio=A(this.easing(this.frame/this.maxFrame)*this.targetRatio,0,this.targetRatio,this.lastRatio,this.targetRatio),this.ratio=Math.max(Math.min(this.ratio,1),0),this.frame++,this.age%2==0){const e=this.x,n=this.y,t=this.w*this.ratio,i=this.h;this.children[0].update({x:e,y:n,w:t,h:i,impulse:o});const r=e+t,l=n,s=this.w*(1-this.ratio),c=this.h;this.children[1].update({x:r,y:l,w:s,h:c,impulse:o})}else{const e=this.x,n=this.y,t=this.w,i=this.h*this.ratio;this.children[0].update({x:e,y:n,w:t,h:i,impulse:o});const r=this.x,l=this.y+i,s=this.w,c=this.h*(1-this.ratio);this.children[1].update({x:r,y:l,w:s,h:c,impulse:o})}}else this.draw(!0)}getPositionAndSize(o,e){let n,t,i,r,l;switch(o){case 0:n=0===e||3===e?this.x+f:this.x+this.w-f,t=0===e||1===e?this.y+f:this.y+this.h-f,i=this.z,r=this.w-2*f,l=this.h-2*f;break;case 1:n=this.x+this.w-f,t=0===e||1===e?this.y+f:this.y+this.h-f,i=0===e||3===e?this.z:0,r=this.z,l=this.h-2*f;break;case 2:n=0===e||3===e?this.x+f:this.x+this.w-f,t=0===e||1===e?this.y+f:this.y+this.h-f,i=0,r=this.w-2*f,l=this.h-2*f;break;case 3:n=this.x+f,t=0===e||1===e?this.y+f:this.y+this.h-f,i=0===e||3===e?0:this.z,r=this.z,l=this.h-2*f;break;case 4:n=0===e||3===e?this.x+f:this.x+this.w-f,t=this.y+this.h-f,i=0===e||1===e?this.z:0,r=this.w-2*f,l=this.z;break;case 5:n=0===e||3===e?this.x+f:this.x+this.w-f,t=this.y+f,i=0===e||1===e?this.z:0,r=this.w-2*f,l=this.z}return{x:n,y:t,z:i,w:r,h:l}}draw(o=!1){if(o){const o=this.getScreenPosition();for(let e=0;e<1;e++)for(let n=0;n<4;n++){const t=1*this.id*4+4*e+n,i=g.attributes.position,{x:r,y:l,z:s,w:c,h:a}=this.getPositionAndSize(e,n);i.setXYZ(t,r,l,s),i.needsUpdate=!0;const v=g.attributes.size;v.setXY(t,c,a),v.needsUpdate=!0;const d=g.attributes.ratio;d.setX(t,this.impulse),d.needsUpdate=!0;const u=g.attributes.direction;u.setX(t,this.getDirection()),u.needsUpdate=!0;const m=g.attributes.weight;m.setXY(t,o.x,o.y),m.needsUpdate=!0}}else{this.id=S;const o=this.getScreenPosition();for(let e=0;e<1;e++){for(let n=0;n<4;n++){const{x:t,y:i,z:r,w:l,h:c}=this.getPositionAndSize(e,n);x.push(t,i,r),w.push(l,c),y.push(this.getDirection()),R.push(this.ratio),M.push(o.x,o.y),P.push(s.code?1:0)}for(let o=0;o<4;o++)C.push(this.id),p.push(f,f);z.push(0,0,1,0,1,1,0,1);const n=1*this.id*4+4*e;B.push(n+0,n+1,n+2,n+2,n+3,n+0)}S++}}getDirection(){return Math.abs(this.w-this.h)<100?-1:this.w>this.h?1:0}getCenter(){return{x:this.x+this.w/2,y:this.y+this.h/2}}getScreenPosition(){const o=this.getCenter(),e=window.innerWidth,n=H;return{x:(o.x+e/2)/e,y:(o.y+n/2)/n}}}const W=[o=>1+2.70158*Math.pow(o-1,3)+1.70158*Math.pow(o-1,2)];window.addEventListener("resize",Y),S=0,d.clear(),C=[],x=[],z=[],B=[],p=[],w=[],y=[],R=[],M=[],h=new D(-window.innerWidth/2,-H/2,window.innerWidth,H,0),(()=>{g=new THREE.BufferGeometry,g.setIndex(B),g.setAttribute("index",new THREE.Uint16BufferAttribute(C,1)),g.setAttribute("totalIndex",new THREE.Float32BufferAttribute([...Array(C.length)].map(((o,e)=>S)),1)),g.setAttribute("position",new THREE.Float32BufferAttribute(x,3)),g.setAttribute("uv",new THREE.Uint16BufferAttribute(z,2)),g.setAttribute("size",new THREE.Float32BufferAttribute(w,2)),g.setAttribute("padding",new THREE.Float32BufferAttribute(p,2)),g.setAttribute("direction",new THREE.Float32BufferAttribute(y,1)),g.setAttribute("ratio",new THREE.Float32BufferAttribute(R,1)),g.setAttribute("weight",new THREE.Float32BufferAttribute(M,2)),g.setAttribute("showCode",new THREE.Float32BufferAttribute(P,1));const o=r.getPaletteAsRGB(s.palette);I.headerColor1.value=new THREE.Vector3(...o.header1),I.headerColor2.value=new THREE.Vector3(...o.header2),I.contentColor1.value=new THREE.Vector3(...o.content1),I.contentColor2.value=new THREE.Vector3(...o.content2),I.contentColor3.value=new THREE.Vector3(...o.content3),I.contentColor4.value=new THREE.Vector3(...o.content4),I.contentColor5.value=new THREE.Vector3(...o.content5);const e=new THREE.RawShaderMaterial({uniforms:I,vertexShader:c,fragmentShader:a,transparent:!0,blending:THREE.NormalBlending,depthTest:!0,wireframe:!1,side:THREE.DoubleSide,glslVersion:THREE.GLSL1});b=new THREE.Mesh(g,e),d.add(b)})(),Y(),X()})()})();
</script>
</body></html>
